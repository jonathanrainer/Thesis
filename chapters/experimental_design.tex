\chapter{Implementation \& Experimental Design}
\label{chap:experimental-design}

So far in this thesis we have seen examples of what a system that implements trace assisted caching might look like from a very high level. In this chapter we are going to explore the actual implementation of this scheme that was undertaken as part of this project. We'll first explore some of the pre-existing components that were used, and then follow that by discussing the development of each of the new elements that were necessary to implement the scheme. To conclude we'll discuss the actual experiment that is to be run and illustrate some of the tooling that was developed to enable this to proceed smoothly.

\section{Pre-existing Components}

When beginning the construction of the hardware necessary to implement trace-assisted caching there are several modules that we can simply re-purpose from other projects. Starting with the processor as a whole, for these experiments we are going to use the \texttt{RI5CY}\cite{gautschiNearThresholdRISCVCore2017} processor from the PULP Foundation which implements the \texttt{RISC-V} ISA. The \texttt{RI5CY} is a 32-bit, in order processor with a 4-stage pipeline. It supports the RV32I,RV32C and RV32M standards found within the \texttt{RISC-V} standard which allows for integer computation, compressed instructions and integer multiplication and division. There is an optional floating point mechanism but that will not be included in our instance of the \texttt{RI5CY}. A big benefit of the \texttt{RI5CY} is that it has a Harvard Architecture, making it ideal for these experiments because we can isolate the data memory to more accurately to quantify the benefit from trace assisted caching. In addition because the \texttt{RISC-V} ISA is based on classic \gls{risc} we don't have to be concerned about multiple esoteric addressing modes or microcode as we might have to with a \gls{cisc} architecture. 

As the \texttt{RI5CY} processor is released under the OpenHardware \cite{OpenSourceHardware} initiative all of the source code is publically available to be changed to be scrutinised and adapted if necessary. We will need to make certain changes to the \texttt{RI5CY} processor to expose some internal signals, but because we have source code access and Vivado can synthesise this code into a hardware description for an \gls{fpga} this is less problematic than it otherwise might be. This will be dealt with more fully in the next section where we discuss the trace recorder. A further benefit of using the \texttt{RI5CY} processor is that it has already been integrated into the PULPino \gls{soc} which was built using the Xilinx Vivado toolchain. This means there are several ancillary hardware blocks, available online, that allow the \texttt{RI5CY}'s native memory protocol to talk to the Xilinx proprietary \texttt{AXI} protocol, used to communicate easily with the various hardware blocks on the \gls{fpga} this means we can re-use lots of different \texttt{AXI} based memory implementations without having to write our own adapter. This adapter is known as a \texttt{core2axi} block. 

Turning now to the memory implementation we will use, Xilinx provide a feature as part of newer versions of Vivado known as \glspl{xpm}. What these \glspl{xpm} allow is for you to specify the parameters of your memory implementation (size, address width, latency etc.) and then delegate the problem of constructing such a memory system to Vivado's in-built tool set. You can communicate with this memory system using the \texttt{AXI} protocol, all the interfaces for which are generated by Vivado itself. This allows us to specify the instruction memory and data memory separately in a much simpler way than having to write all the code to implement the \texttt{AXI} protocol and manage individual physical memory elements. 

So at this point we have a fully functioning processor, connected to two physically separate memory implementations, generated by the \glspl{xpm}. Between the processor and the \texttt{AXI} ports on the \gls{xpm} generated memory are two \texttt{core2axi} blocks that convert the processors native memory protocol to a set of signals that conform to the \texttt{AXI4} standard. A diagram of the current architecture can be seen below

%TODO Insert diagram of starting architecture 

\section{Trace Recorder (Gouram)}

Now that we have a sensible starting point it's possible to consider the construction of the trace recorder part of Kuuga, this will be known as Gouram. To start with, we need a way to track the execution of each instruction as it passes through the various pipeline stages of the processor. Further to that we need to track the effective addresses of each memory instruction as they are generated by the running program. The basic construction for this new piece of hardware will be to have it made of two submodules, the first will track the \texttt{IF}/\texttt{ID} phase of the pipeline execution and the second will track the \texttt{EX} phase. We do not need to track the \texttt{WB} phase because it will have no bearing on either the effective address or the timing of other instructions as it's merely a formality that results get written back to registers. This overall architecture can be seen in Figure [??]. First to help us understand how each phase will work it's important that we understand the memory protocol that is implemented by the \texttt{RI5CY} processor. With that in hand we can move forward to describing each of sub-blocks and then the overall trace recorder module and the data it produces.

% TODO Insert diagram of Gouram

\subsection{\texttt{RI5CY} Memory Protocol}

The memory protocol that is implemented by the \texttt{RI5CY} is documented in the processor manual \cite{andreastraberRI5CYUserManual2017}. However it bears slightly further explanation there are certain parts of the protocol that we will rely on or have to workaround in order for Gouram to function correctly. To begin there are 8 signals that the \gls{lsu} uses to communicate with the memory hardware and these are listed in the Figure \ref{fig:signal-table}, reproduced from the processor manual:

\begin{figure}[htbp]
	\renewcommand{\arraystretch}{1.4}
	\begin{tabular}{lccp{8cm}}
		\hline
		\textbf{Signal} & \textbf{Bit Width} &\textbf{Direction} & \textbf{Description} \\
		\hline
		\texttt{data\_req\_o}& 1 & Output & Request ready, must stay high until \texttt{data\_gnt\_i} is high for one cycle. \\
		\texttt{data\_addr\_o} & 32 & Output & Address \\
	  	\texttt{data\_we\_o}& 1 & Output & Write Enable, high for writes, low for reads. Sent together with \texttt{data\_req\_o}. \\
	  	\texttt{data\_be\_o} & 4 & Output & Byte Enable. Is set for the bytes to write/read, sent together with \texttt{data\_req\_o}. \\
	  	\texttt{data\_wdata\_o} & 32& Output & Data to be written to memory, sent together with \texttt{data\_req\_o}. \\
	  	\texttt{data\_rdata\_i} & 32 & Input & Data read from memory. \\
		\texttt{data\_rvalid\_i} & 1 & Input & \texttt{data\_rdata\_i} holds valid data when \texttt{data\_rvalid\_i} is high. This signal will be high for exactly one cycle per request. \\
		\texttt{data\_gnt\_i} & 1 & Input & The other side accepted the request. \texttt{data\_addr\_o} may change in the next cycle. \\
		\hline
	\end{tabular}
\caption{List of input and output signals provided by the \gls{lsu} to implement the memory protocol for the \texttt{RI5CY}, reproduced from the processor manual \cite{andreastraberRI5CYUserManual2017}}
\label{fig:signal-table}
\end{figure}

The protocol then proceeds thus. When an instruction requires access to memory the \gls{lsu} sets \texttt{data\_req\_o} high, whilst at the same time placing the calculated address (\texttt{data\_addr\_o}, byte enable bits (\texttt{data\_be\_o}), any data to be written to memory (\texttt{data\_wdata\_o)} and selecting a read or a write with \texttt{data\_we\_o}. Then the processor waits for the memory system to respond by setting \texttt{data\_gnt\_i} high. Once this has happened the processor can change any of the 4 signals it set originally, assuming them to be cached in the memory controller now \texttt{data\_gnt\_i} is high. This may happen in the same cycle that \texttt{data\_req\_o} goes high or it may take several cycles with a slower memory technology. After the grant the memory system will execute the load or store as required and once it has completed it will set \texttt{data\_rvalid\_i} high. This will happen after at least 1 clock cycle from the setting of \texttt{data\_gnt\_i} to high. Once \texttt{data\_rvalid\_i} is high \texttt{data\_rdata\_i} will contain the fetched data from memory in the case of a \texttt{LOAD} or arbitrary data in the case of a \texttt{STORE}. If another memory request is queued, \texttt{data\_req\_o} will be set high at the same time that \texttt{data\_rvalid\_i} is and the processor continues. Several examples of timing diagrams are included below to illustrate how this protocol works.
	
\begin{figure}
	% LOAD
	\begin{subfigure}{\textwidth}
		\begin{tikztimingtable}[timing/xunit=20, timing/yunit=10]
			clk        & 29{c}@{\gtikzset{timing/rowdist=3}}\\
			data\_in   & @{\gtikzset{timing/rowdist=2}}[y=2\yunit]0.1l 
			[[timing/slope=0.7]]hhhhllllllhhhhhlllll 0.4lhhhhlllll\\
			error      & lllhhhhhhhhllhhhhhhh hllhhhhhh\\
			error\_reg & lllllhhhhhhhhllhhhhh hhhllhhhh\\
			data       & lhhhhhhllllhhhhhhlll lllhhhhll\\
			data\_reg  & lllhhhhhhllllhhhhhhl lllllhhhh\\
			early      & lllllllllllhhlllllll lllllllll\\
			late       & llllllllllllllllllll lllhhllll\\
			\extracode \background
			\begin{scope}[gray,semitransparent,semithick,node font=\tiny,anchor=west]
				\vertlines{0.5,...,\twidth}
			\end{scope}
			\endbackground
		\end{tikztimingtable}
	\end{subfigure}
	% STORE
	\begin{subfigure}{\textwidth}
%				\begin{tikztimingtable}
%			clk        & 29{c}@{\gtikzset{timing/rowdist=3}}\\
%			data\_in   & @{\gtikzset{timing/rowdist=2}}[y=2\yunit]0.1l 
%			[[timing/slope=0.7]]hhhhllllllhhhhhlllll 0.4lhhhhlllll\\
%			error      & lllhhhhhhhhllhhhhhhh hllhhhhhh\\
%			error\_reg & lllllhhhhhhhhllhhhhh hhhllhhhh\\
%			data       & lhhhhhhllllhhhhhhlll lllhhhhll\\
%			data\_reg  & lllhhhhhhllllhhhhhhl lllllhhhh\\
%			early      & lllllllllllhhlllllll lllllllll\\
%			late       & llllllllllllllllllll lllhhllll\\
%			\extracode \background
%			\begin{scope}[gray,semitransparent,semithick,node font=\tiny,anchor=west]
%				\vertlines{0.5,...,\twidth}
%				\draw (row2.high start) ++(0,-0.1) -- ++(16,0) node {Vrefp};
%				\draw (row2.low start)  ++(0, 0.1) -- ++(16,0) node {Vrefn};
%			\end{scope}
%			\endbackground
%		\end{tikztimingtable}
	\end{subfigure}
	% BACKTOBACK
	\begin{subfigure}{\textwidth}
%				\begin{tikztimingtable}
%			clk        & 29{c}@{\gtikzset{timing/rowdist=3}}\\
%			data\_in   & @{\gtikzset{timing/rowdist=2}}[y=2\yunit]0.1l 
%			[[timing/slope=0.7]]hhhhllllllhhhhhlllll 0.4lhhhhlllll\\
%			error      & lllhhhhhhhhllhhhhhhh hllhhhhhh\\
%			error\_reg & lllllhhhhhhhhllhhhhh hhhllhhhh\\
%			data       & lhhhhhhllllhhhhhhlll lllhhhhll\\
%			data\_reg  & lllhhhhhhllllhhhhhhl lllllhhhh\\
%			early      & lllllllllllhhlllllll lllllllll\\
%			late       & llllllllllllllllllll lllhhllll\\
%			\extracode \background
%			\begin{scope}[gray,semitransparent,semithick,node font=\tiny,anchor=west]
%				\vertlines{0.5,...,\twidth}
%				\draw (row2.high start) ++(0,-0.1) -- ++(16,0) node {Vrefp};
%				\draw (row2.low start)  ++(0, 0.1) -- ++(16,0) node {Vrefn};
%			\end{scope}
%			\endbackground
%		\end{tikztimingtable}
	\end{subfigure}
\end{figure}

It should be pointed out that this protocol works for the instruction memory as well but uses a reduced number of signals as the instruction memory cannot be written to. These signals are labelled \texttt{inst\_req\_o} etc.

% General Idea, 3 blocks to track each part of the execution
% Explain the memory protocol from RI5CY
% Explain each block in, showing the signals you need to expose from the processor to make it work, state diagrams in each case
% Show how each block interconnects to pass state between each one

\section{Trace Assisted Cache \#1 - Direct Mapped (Saruyu)}

\section{Trace Assisted Cache \#2 - 8-Way Associative (Enokida)}

\section{Experimental Setup}

